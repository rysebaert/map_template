mf_map(inset, col = "red")
mf_label(inset, var = "name", col = "black", cex = .6, halo = TRUE)
# Chunk 10
# Les masques sont définis en 4326, on modifie donc la projection d'entrée
can_proj <- st_cast(can_proj, "MULTIPOLYGON")
can_i <- m_r(x = can_proj, mask = can_m_proj,  y = inset[1,])
par(mfrow = c(1,2))
mf_map(frame)
mf_map(inset, col = "red", border = NA, add = TRUE)
mf_map(can_i, col = "white", border = NA, add = TRUE)
mf_map(inset, col = "red", border = NA)
mf_map(can_i, col = "white", border = NA, add = TRUE)
# Chunk 11
multiple_m_r <- function(x, param, bind = FALSE, bind_layer = NULL, frame,
return_k = FALSE){
# Renommage des fichiers
df <- param
input <- x
# Préparation du fichier de sortie
out <- data.frame(matrix(nrow = 1, ncol = ncol(x)-1))
colnames(out) <- colnames(x)[1:ncol(x)-1]
# Gérer les différents types d'objet en entrée
type <- st_geometry_type(x, by_geometry = FALSE)
if(type %in% c("MULTIPOLYGON", "GEOMETRY")){
out <- st_sf(out, geometry = st_sfc(lapply(1, function(x) st_multipolygon())))
} # Si couche à extraire est de type polygone
if(type == "POINT"){
out <- st_sf(out, geometry = st_sfc(lapply(1, function(x) st_point())))
} # Ou point
# Projection des xmin, xmax, ymin, ymax
st_crs(out) <- unique(df$i_epsg)
# Préparation du fichier de sortie si l'on souhaite en sortie le facteur R
if(return_k == TRUE){
out <- data.frame(matrix(nrow = nrow(df), ncol = 2))
colnames(out) <- c(names(df)[1], "k")
out[, "name"] <- df[,"name"]
}
# Reproduire l'ensemble des étapes utiles à l'extraction / reprojection
for (i in 1 : nrow(df)){
# Extraire la projection locale
epsg_loc <- df[i, "m_epsg_loc"]
# Créer le masque à partir des paramètres
mask <- make_poly(x = df[i,], crs = df[i, "m_epsg"],
xmin = "m_xmin", ymin = "m_ymin", xmax = "m_xmax", ymax = "m_ymax")
# Transformer la couche d'entrée dans la projection spécifiée (surtout utiles pour les pays du Monde)
x <- st_transform(input, df[i, "m_epsg"])
st_agr(x) <- "constant"
# Ne conserver que le voisinage du masque (200 km)
x <- st_intersection(x, st_buffer(mask, 200000))
# Gestion des géométries
if(type %in% c("MULTIPOLYGON", "GEOMETRY")){
x <- st_cast(x, "MULTIPOLYGON")
}
# Transformation dans la projection locale
mask <- st_transform(mask, epsg_loc)
x <- st_transform(x, epsg_loc)
# Créer l'inset
inset <- make_poly(x = df[i,], crs = df[i, "i_epsg"],
xmin = "i_xmin", ymin = "i_ymin", xmax = "i_xmax", ymax = "i_ymax")
# Resize & moove
if(return_k == FALSE){
if(nrow(x) > 0){
x <- m_r(x = x, mask = mask, y = inset, return_k = FALSE)
out <- rbind(x, out)
}
}
# Si l'on souhaite le facteur k
if(return_k == TRUE){
x <- m_r(x = x, mask = mask, y = inset, return_k = TRUE)
out[i,"k"] <- x
}
}
# Joindre ou non ces résultats à une couche de sortie
if(bind == TRUE){
bind_layer <- st_transform(input, unique(df$i_epsg))
out <- rbind(out, bind_layer)
st_agr(out) <- "constant"
out <- st_intersection(out, frame)
}
return(out)
}
# Chunk 12
#| warning: false
nuts2 <- gisco_get_nuts(epsg = "3035",   nuts_level = "2", resolution = "20",
year = "2021")
nuts3 <- gisco_get_nuts(epsg = "3035",   nuts_level = "3", resolution = "20",
year = "2021")
nuts <- rbind(nuts2, nuts3)
nuts <- multiple_m_r(x = nuts, param = df, bind = TRUE, frame = frame)
mf_map(nuts, col = "peachpuff", border = "white", lwd = .5, add = T)
mf_map(nuts[duplicated(nuts$NUTS_ID),], col = "red")
# Chunk 13
nuts <- aggregate(nuts, by = list(NUTS_ID = nuts$NUTS_ID),
FUN = head, 1)
# Chunk 14
input <- gisco_get_nuts(epsg = "3035",   nuts_level = "2", resolution = "20",
year = "2021")
k <- multiple_m_r(x = input, param = df, return_k = TRUE)
k
# Chunk 15
boxes <- make_poly(df, crs = unique(df$i_epsg),
xmin = "i_xmin", ymin = "i_ymin", xmax = "i_xmax", ymax = "i_ymax")
# Chunk 16
country <- gisco_get_countries(year = "2020", resolution = "20")
country <- st_transform(country, 3035)
country_box <- multiple_m_r(x = country, param = df, bind = FALSE, frame = frame)
country <- st_intersection(country, frame)
borders <- cartography::getBorders(country)
borders2 <- cartography::getBorders(country_box)
borders <- rbind(borders, borders2)
# Chunk 17
library(rnaturalearth)
cities <- ne_download(scale = 110, type = "populated_places", category = "cultural")
cities <- st_transform(cities, 3035)
cities <- st_intersection(cities, frame)
cities <- cities[,"NAME"]
cities <- cities[!cities$NAME %in% c("Vatican City",
"San Marino",
"Monaco",
"Andorra",
"Moscow",
"The Hague",
"Casablanca",
"Istanbul"),]
# Chunk 18
# Voir les dimensions de la carte à partir du frame
mf_get_ratio(x = frame, width = 7, expandBB = rep(-.04, 4))
# Chunk 19
#| fig-width: 7
#| fig-height: 6.28
par(mfrow = c(1,1))
mf_theme(
bg = "white", fg = "black", mar = c(0, 0, 0, 0),
tab = TRUE, inner = TRUE, line = 1.3, cex = 1.1, font = 2
)
mf_map(frame, col = "lightblue", expandBB = rep(-.04, 4), border = NA)
mf_map(country, col = "lightgrey", border = NA, add = TRUE)
mf_map(boxes, col = "lightblue", border = NA, add = TRUE)
mf_map(country_box, col = "lightgrey", border = NA, add = TRUE)
mf_map(nuts, col = "peachpuff", border = "white", lwd = .25, add = TRUE) # Future couche possible pour la
#représentation carto
mf_map(borders, col = "white", add = TRUE)
mf_map(cities, pch = 21, col = NA, bg = "black", cex = .4, add = TRUE) # Future couche possible pour la
#représentation carto
mf_label(cities, var = "NAME", halo = TRUE, cex = .4, pos = 2)
mf_map(boxes, col = NA, add = TRUE)
mf_map(frame, col = NA, lwd = 1, add = TRUE)
mf_credits("Source : Eurostat, GISCO, 2024")
mf_scale(size = 500)
mf_title("Map template")
# Chunk 20
# Couches d'habillage sous la carte thématique
map_background <- function(x){
mf_map(frame, col = "lightblue", expandBB = rep(-.04, 4), border = NA)
mf_map(country, col = "lightgrey", border = NA, add = TRUE)
mf_map(boxes, col = "lightblue", border = NA, add = TRUE)
mf_map(country_box, col = "lightgrey", border = NA, add = TRUE)
}
# Couches d'habillage sur la carte thématique
map_foreground <- function(sources, title){
mf_map(borders, col = "white", lwd = 1, add = TRUE)
mf_map(boxes, col = NA, add = TRUE)
mf_map(frame, col = NA, lwd = 1, add = TRUE)
mf_credits(txt = sources)
mf_scale(size = 500)
mf_title(txt = title)
}
# Chunk 21
#| fig-width: 7
#| fig-height: 6.28
# Un code condensé pour une jolie carte
map_background()
mf_map(x = nuts, var = "CNTR_CODE", type = "typo", pal = "Set 3",
border = "white", leg_pos = NA, add = TRUE)
map_foreground(title = "Les pays européens", source = "Eurostat, GISCO, 2024")
# Chunk 22
library(eurostat)
df <- get_eurostat("reg_area3", time_format = "num") # Telecharger la table ESTAT
df <- df[df$landuse == "TOTAL",]
df <- dcast(df, geo ~ TIME_PERIOD, value.var = "values") # Redimensionnement de la table au format geo
head(df)
# Chunk 23
estat_last_year <- function(x, x_id, df, df_id, var){
# Filtrer sur les objets cibles
df <- df[df[,df_id] %in% x[,x_id, drop = TRUE],]
tmp <- df
# Chercher la dernière colonne sans valeur manquante
df[,var] <- df[cbind(1:nrow(df), max.col(!is.na(df), ties.method = 'last'))]
# Chercher cette année de référence
tmp$xx <- substr(colnames(tmp[max.col(!is.na(tmp), 'last')]), 1, 4)
# Définir pour nom de colonne la valeur moyenne arrondie pour l'ensemble des unités
colyearname <- paste0(var, "_", round(mean(as.numeric(tmp$xx), na.rm = TRUE), 0))
# Et l'affecter
names(df)[length(df)] <- colyearname
# S'assurer que c'est bien du numérique
df[,length(df)] <- as.numeric(df[,length(df)])
x <- merge(x, df[,c(1, length(df))], by.x = x_id, by.y = df_id, all.x = TRUE)
return(x)
}
# Chunk 24
nuts <-estat_last_year(x = nuts, x_id = "NUTS_ID", df = df, df_id = "geo",
var = "AREA")
# Chunk 25
est <- nuts[is.na(nuts$AREA_2024),]
est$AREA_2024 <- as.numeric(st_area(est)/1000000)
nuts <- nuts[!is.na(nuts$AREA_2024),]
nuts <- rbind(nuts, est)
# Chunk 26
df <- get_eurostat("demo_r_pjanaggr3", time_format = "num")
df <- df[df$sex == "T",]
df <- df[df$age == "TOTAL",]
df <- dcast(df, geo ~ TIME_PERIOD, value.var = "values")
nuts <- estat_last_year(x = nuts, x_id = "NUTS_ID",
df = df, df_id = "geo", var = "POP")
# Chunk 27
id_estat <- "demo_r_pjanaggr3"
toc <- get_eurostat_toc(lang = "fr")
toc <- toc[toc$code == id_estat,]
last_update <- toc$last.update.of.data[1]
# Chunk 28
#| fig-width: 7
#| fig-height: 6.28
nuts$DENS <- nuts$POP_2023 / nuts$AREA_2024
# Fond de carte avec différentes couches d'habillage
map_background()
mf_map(nuts, var = "DENS", type = "choro", pal = "Heat 2", nbreaks = 6,
border = NA, add = TRUE, leg_title = "Densité de population\n(habitants/km²)",
leg_pos = c(2050000, 4700000), leg_no_data = "Pas de données")
mf_map(cities, pch = 21, col = NA, bg = "black", cex = .6, add = TRUE)
mf_label(cities, var = "NAME", halo = TRUE, cex = .4, pos = 4)
map_foreground(title = "Densité de population (NUTS3)",
sources = paste("Eurostat, GISCO, 2024 / Table", id_estat,
"/ Dernière mise à jour : ", last_update,
sep = " "))
nuts <- nuts[,c("NUTS_ID", "NAME_LATN", "LEVL_CODE", "URBN_TYPE", "MOUNT_TYPE",
"AREA_2024", "POP_2023")]
unique(st_is_valid(nuts)) # TRUE
nuts2 <- nuts[nuts$LEVL_CODE == "2",]
nuts3 <- nuts[nuts$LEVL_CODE == "3",]
st_write(nuts2, "output/nuts2.geojson")
st_write(nuts3, "output/nuts3.geojson")
st_write(frame, "output/frame.geojson")
country <- country[,c("CNTR_ID", "CNTR_NAME")]
unique(st_is_valid(country)) # TRUE
st_write(country, "output/country.geojson")
country_box <- country_box[,c("CNTR_ID", "CNTR_NAME")]
unique(st_is_valid(country_box)) # TRUE
st_write(country_box, "output/country_box.geojson")
unique(st_is_valid(boxes)) # TRUE
st_write(boxes, "output/boxes.geojson")
unique(st_is_valid(borders)) # TRUE
borders <- st_set_crs(borders, 3035)
st_write(borders, "output/borders.geojson")
# Ne conserver que les champs utiles
nuts <- nuts[,c("NUTS_ID", "NAME_LATN", "LEVL_CODE", "URBN_TYPE", "MOUNT_TYPE",
"AREA_2024", "POP_2023")]
unique(st_is_valid(nuts)) # TRUE
nuts2 <- nuts[nuts$LEVL_CODE == "2",]
nuts3 <- nuts[nuts$LEVL_CODE == "3",]
st_write(nuts2, "output/eu_template_nuts2.geojson")
st_write(nuts3, "output/eu_template_nuts3.geojson")
st_write(frame, "output/eu_template_frame.geojson")
country <- country[,c("CNTR_ID", "CNTR_NAME")]
unique(st_is_valid(country)) # TRUE
st_write(country, "output/eu_template_country.geojson")
country_box <- country_box[,c("CNTR_ID", "CNTR_NAME")]
unique(st_is_valid(country_box)) # TRUE
st_write(country_box, "output/eu_template_country_box.geojson")
unique(st_is_valid(boxes)) # TRUE
st_write(boxes, "output/eu_template_boxes.geojson")
unique(st_is_valid(borders)) # TRUE
borders <- st_set_crs(borders, 3035)
st_write(borders, "output/eu_template_borders.geojson")
st_write(cities, "output/eu_template_cities.geojson")
dev.off()
# Chunk 1
library(giscoR)
library(eurostat)
library(sf)
#devtools::install_github("riatelab/mapinsetr", force = TRUE)
library(mapinsetr)
library(mapsf)
library(reshape2)
# Chunk 2
nuts <- gisco_get_nuts(epsg = "3035",   nuts_level = 2, resolution = "20", year = "2021",
cache_dir = "input", cache = TRUE)
mf_map(nuts)
# Chunk 3
# Définition des limites du modèles cartographique (800 * 1000)
bbox <- st_bbox(obj = c(xmin = 1920000, ymin = 1300000,  xmax = 6600000, ymax = 5500000),
crs = 3035)
frame <- st_sf(geom = st_as_sfc(bbox))
mf_map(frame, col = "lightblue")
mf_map(nuts, col = "peachpuff", border = "white",add = TRUE)
# Chunk 4
# Nombre d'insets
n <- 9
# Préparer le tableau requis
df <- data.frame(matrix(ncol = 1, nrow = n))
names(df) <- c("name")
# Nom des territoires
df$name <- c("Canaries (ES)", "Madeire (PT)", "Açores (PT)",
"Açores, Florès (PT)", "Guadeloupe (FR)", "Martinique (FR)",
"Réunion (FR)", "Guyane (FR)", "Mayotte (FR)")
# Masques (Coordonnées géographiques de la localisation en long/lat des territoires périphériques)
df$m_xmin <- c(-18.4, -17.35, -28.9, -31.4, -62.05, -61.44, 54.99, -55.5, 44.5)
df$m_ymin <- c(27.4, 32.55, 36.8, 39.3, 15.64, 14.19, -21.61, 1.8, -13.5)
df$m_xmax <- c(- 13.3, -16.2, -24.8, -30.9, -60.99, -60.6, 56.06, -50.8, 45.8)
df$m_ymax <- c(29.5, 33.2, 40.2, 39.8, 16.71, 15.09, -20.64, 6, -12.2)
df$m_epsg <- 4326
df$m_epsg_loc <- c(3035, 2191, 3063, 3063, 5490, 5490, 2975, 2972, 4471)
# Insets ----
# Paramètres généraux des boîtes (2 colonnes * 4 boîtes régulièrement espacées) ----
box_area <- 280000 # largeur / hauteur
x_min <- 5900000 # Xmin pour toutes les boîtes de la première colonne
y_max <- 5100000 # Ymax (haut des boîtes)
box_space <- 43000 # espace entre les boîtes
# Futur réceptacle des coordonnées des insets
df$i_xmin <- NA
df$i_ymin <- NA
df$i_xmax <- NA
df$i_ymax <- NA
# Canaries
xmin <- x_min
xmax <- xmin + (box_area * 2) + box_space
ymax <- y_max
ymin <- ymax - box_area
df[1, c(8:11)] <- c(xmin, ymin, xmax, ymax)
# Madère
xmin <- x_min
xmax <- xmin + box_area
ymax <- ymin - box_space
ymin <- ymax - box_area
df[2, c(8:11)] <- c(xmin, ymin, xmax, ymax)
## Açores (main) ----
xmin <- xmax + box_space
xmax <- xmin + box_area
df[3, c(8:11)] <- c(xmin, ymin, xmax, ymax)
## Açores (second) ----
xmax <- xmin + (.3 * (xmax - xmin))
ymin2 <- ymax - (.3 * (ymax - ymin))
df[4, c(8:11)] <- c(xmin, ymin2, xmax, ymax)
## Guadeloupe ----
xmin <- x_min
xmax <- xmin + box_area
ymax <- ymin - box_space
ymin <- ymax - box_area
df[5, c(8:11)] <- c(xmin, ymin, xmax, ymax)
## Martinique ----
xmin <- xmax + box_space
xmax <- xmin + box_area
df[6, c(8:11)] <- c(xmin, ymin, xmax, ymax)
## Réunion ----
xmin <- x_min
xmax <- xmin + box_area
ymax <- ymin - box_space
ymin <- ymax - box_area
df[7, c(8:11)] <- c(xmin, ymin, xmax, ymax)
## Guyane ----
xmin <- xmax + box_space
xmax <- xmin + box_area
df[8, c(8:11)] <- c(xmin, ymin, xmax, ymax)
## Mayotte ----
xmin <- x_min + (box_area / 2)
xmax <- xmin + box_area
ymax <- ymin - box_space
ymin <- ymax - box_area
df[9, c(8:11)] <- c(xmin, ymin, xmax, ymax)
# EPSG (inset)
df$i_epsg <- 3035
# Chunk 5
knitr::kable(df)
# Chunk 6
make_poly <- function(x, xmin, ymin, xmax, ymax, crs, epsg_loc = NULL,
name = NULL){
# Préparation fichier de sortie
out <- data.frame(matrix(nrow = 1, ncol = 2))
out <- st_sf(out, geometry = st_sfc(lapply(1, function(x) st_multipolygon())))
colnames(out)[1:2] <- c("name", "epsg")
st_crs(out) <- crs
# Créer les polygones à partir des coordonnées spécifiées
for (i in 1:nrow(x)){
bbox <- st_bbox(obj = c(xmin = x[i, xmin], ymin = x[i, ymin],
xmax = x[i, xmax], ymax = x[i, ymax]))
out[i,"geometry"] <- st_as_sfc(bbox)}
# Associer les attributs utiles
out$epsg <- epsg_loc
out$name <- name
return(out)
}
# Chunk 7
mask <- make_poly(x = df,
xmin = "m_xmin", ymin = "m_ymin", xmax = "m_xmax", ymax = "m_ymax",
crs = unique(df$m_epsg),
epsg_loc = df$m_epsg_loc)
mf_map(mask, col = "red", border = "white")
mf_map(st_transform(nuts, 4326), border = "white", add = TRUE)
# Chunk 8
# Exemple des Canaries
can_m <- mask[1,]
# Entrée, Canaries en 4326
par(mfrow = c(1,2))
mf_map(can_m, col = "red", border = "white")
mf_map(st_transform(nuts, 4326), border = NA, add = TRUE)
# Prise en compte de la projection locale pour le masque et les territoires
can_m_proj <- st_transform(can_m, mask[1, "epsg", drop = TRUE])
can_proj <- st_transform(nuts, mask[1, "epsg", drop = TRUE])
mf_map(can_m_proj, col = "red", border = "white")
mf_map(can_proj, add = TRUE, border = NA)
# Chunk 9
inset <- make_poly(x = df, name = df$name,
xmin = "i_xmin", ymin = "i_ymin", xmax = "i_xmax", ymax = "i_ymax",
crs = unique(df$i_epsg))
par(mfrow = c(1,2))
mf_map(frame, col = "lightblue")
mf_map(inset, col = "red", add = TRUE)
mf_map(inset, col = "red")
mf_label(inset, var = "name", col = "black", cex = .6, halo = TRUE)
# Chunk 10
# Les masques sont définis en 4326, on modifie donc la projection d'entrée
can_proj <- st_cast(can_proj, "MULTIPOLYGON")
can_i <- m_r(x = can_proj, mask = can_m_proj,  y = inset[1,])
par(mfrow = c(1,2))
mf_map(frame)
mf_map(inset, col = "red", border = NA, add = TRUE)
mf_map(can_i, col = "white", border = NA, add = TRUE)
mf_map(inset, col = "red", border = NA)
mf_map(can_i, col = "white", border = NA, add = TRUE)
# Chunk 11
multiple_m_r <- function(x, param, bind = FALSE, bind_layer = NULL, frame,
return_k = FALSE){
# Renommage des fichiers
df <- param
input <- x
# Préparation du fichier de sortie
out <- data.frame(matrix(nrow = 1, ncol = ncol(x)-1))
colnames(out) <- colnames(x)[1:ncol(x)-1]
# Gérer les différents types d'objet en entrée
type <- st_geometry_type(x, by_geometry = FALSE)
if(type %in% c("MULTIPOLYGON", "GEOMETRY")){
out <- st_sf(out, geometry = st_sfc(lapply(1, function(x) st_multipolygon())))
} # Si couche à extraire est de type polygone
if(type == "POINT"){
out <- st_sf(out, geometry = st_sfc(lapply(1, function(x) st_point())))
} # Ou point
# Projection des xmin, xmax, ymin, ymax
st_crs(out) <- unique(df$i_epsg)
# Préparation du fichier de sortie si l'on souhaite en sortie le facteur R
if(return_k == TRUE){
out <- data.frame(matrix(nrow = nrow(df), ncol = 2))
colnames(out) <- c(names(df)[1], "k")
out[, "name"] <- df[,"name"]
}
# Reproduire l'ensemble des étapes utiles à l'extraction / reprojection
for (i in 1 : nrow(df)){
# Extraire la projection locale
epsg_loc <- df[i, "m_epsg_loc"]
# Créer le masque à partir des paramètres
mask <- make_poly(x = df[i,], crs = df[i, "m_epsg"],
xmin = "m_xmin", ymin = "m_ymin", xmax = "m_xmax", ymax = "m_ymax")
# Transformer la couche d'entrée dans la projection spécifiée (surtout utiles pour les pays du Monde)
x <- st_transform(input, df[i, "m_epsg"])
st_agr(x) <- "constant"
# Ne conserver que le voisinage du masque (200 km)
x <- st_intersection(x, st_buffer(mask, 200000))
# Gestion des géométries
if(type %in% c("MULTIPOLYGON", "GEOMETRY")){
x <- st_cast(x, "MULTIPOLYGON")
}
# Transformation dans la projection locale
mask <- st_transform(mask, epsg_loc)
x <- st_transform(x, epsg_loc)
# Créer l'inset
inset <- make_poly(x = df[i,], crs = df[i, "i_epsg"],
xmin = "i_xmin", ymin = "i_ymin", xmax = "i_xmax", ymax = "i_ymax")
# Resize & moove
if(return_k == FALSE){
if(nrow(x) > 0){
x <- m_r(x = x, mask = mask, y = inset, return_k = FALSE)
out <- rbind(x, out)
}
}
# Si l'on souhaite le facteur k
if(return_k == TRUE){
x <- m_r(x = x, mask = mask, y = inset, return_k = TRUE)
out[i,"k"] <- x
}
}
# Joindre ou non ces résultats à une couche de sortie
if(bind == TRUE){
bind_layer <- st_transform(input, unique(df$i_epsg))
out <- rbind(out, bind_layer)
st_agr(out) <- "constant"
out <- st_intersection(out, frame)
}
return(out)
}
# Chunk 12
#| warning: false
nuts2 <- gisco_get_nuts(epsg = "3035",   nuts_level = "2", resolution = "20",
year = "2021")
nuts3 <- gisco_get_nuts(epsg = "3035",   nuts_level = "3", resolution = "20",
year = "2021")
nuts <- rbind(nuts2, nuts3)
nuts <- multiple_m_r(x = nuts, param = df, bind = TRUE, frame = frame)
mf_map(nuts, col = "peachpuff", border = "white", lwd = .5, add = T)
nuts <- aggregate(nuts, by = list(NUTS_ID = nuts$NUTS_ID),
FUN = head, 1)
input <- gisco_get_nuts(epsg = "3035",   nuts_level = "2", resolution = "20",
year = "2021")
k <- multiple_m_r(x = input, param = df, return_k = TRUE)
k
